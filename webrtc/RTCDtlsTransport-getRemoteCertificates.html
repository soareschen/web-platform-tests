<!doctype html>
<meta charset="utf-8">
<title>RTCDtlsTransport.prototype.getRemoteCertificates</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script src="RTCTransport-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //  exchangeIceCandidates
  //  doSignalingHandshake

  // The following helper functions are called from RTCTransport-helper.js:
  //  waitForConnectedState
  //  getDtlsTransportFromSctpTransport
  //  getDtlsTransportsFromSenderReceiver

  function validateConnectedDtlsTransport(dtlsTransport) {
    const certs = dtlsTransport.getRemoteCertificates();

    assert_greater_than(certs.length, 0,
      'Expect DTLS transport to have at least one remote certificate when connected');

    for(const cert of certs) {
      assert_true(cert instanceof ArrayBuffer,
        'Expect certificate elements be instance of ArrayBuffer');
    }
  }

  function validateConnectingDtlsTransport(dtlsTransport) {
    if (dtlsTransport.state !== 'connected') {
      assert_array_equals(dtlsTransport.getCertificates(), [],
        'Expect DTLS certificates be initially empty until become connected');
    }
  }

  promise_test(async t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());

    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    const [track, mediaStream] = await getTrackFromUserMedia('audio')
    addTrackOrTransceiver(pc1, track, mediaStream);
    exchangeIceCandidates(pc1, pc2);

    await doSignalingHandshake(pc1, pc2);

    const dtlsTransports1 = getDtlsTransportsFromSenderReceiver(pc1);
    const dtlsTransports2 = getDtlsTransportsFromSenderReceiver(pc2);

    for (const dtlsTransport of dtlsTransports1) {
      validateConnectingDtlsTransport(dtlsTransport);
    }

    for (const dtlsTransport of dtlsTransports2) {
      validateConnectingDtlsTransport(dtlsTransport);
    }

    await waitForConnectedState(pc1);
    await waitForConnectedState(pc2);

    for (const dtlsTransport of dtlsTransports1) {
      validateConnectedDtlsTransport(dtlsTransport);
    }

    for (const dtlsTransport of dtlsTransports2) {
      validateConnectedDtlsTransport(dtlsTransport);
    }
  }, 'RTP - connected DTLS transports should have valid remote certificates');

  promise_test(async t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());

    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    pc1.createDataChannel('');
    exchangeIceCandidates(pc1, pc2);

    await doSignalingHandshake(pc1, pc2);

    const dtlsTransport1 = getDtlsTransportFromSctpTransport(pc1.sctp);
    const dtlsTransport2 = getDtlsTransportFromSctpTransport(pc2.sctp);

    validateConnectingDtlsTransport(dtlsTransport1);
    validateConnectingDtlsTransport(dtlsTransport2);

    await waitForConnectedState(pc1);
    await waitForConnectedState(pc2);

    validateConnectedDtlsTransport(dtlsTransport1);
    validateConnectedDtlsTransport(dtlsTransport2);
  }, 'SCTP - connected DTLS transports should have valid remote certificates');

</script>
