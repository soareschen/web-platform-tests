<!doctype html>
<meta charset=utf-8>
<title>RTCIceTransport</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script src="RTCTransport-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //  createDataChannelPair
  //  awaitMessage
  //  getTrackFromUserMedia
  //  addTrackOrTransceiver

  // The following helper functions are called from RTCTransport-helper.js:
  //  waitConnectingIceTransport
  //  getIceTransportFromSctp
  //  getIceTransportsFromSenderReceiver


  function validateIceCandidates(candidates) {
    assert_greater_than(candidates.length, 0,
      'Expect at least one ICE candidate returned from get*Candidates()');

    for(const candidate of candidates) {
     assert_true(candidate instanceof RTCIceCandidate,
       'Expect candidate elements to be instance of RTCIceCandidate');
    }
  }

  function validateIceCandidateParameter(param) {
   assert_not_equals(param, null,
     'Expect candidate parameter to be non-null after data channels are connected');

   assert_equals(typeof param.usernameFragment, 'string',
     'Expect param.usernameFragment to be set with string value');

   assert_equals(typeof param.password, 'string',
     'Expect param.password to be set with string value');
  }

  function validateConnectedIceTransport(iceTransport) {
    const { state, gatheringState, role, component } = iceTransport;

    assert_true(role === 'controlling' || role === 'controlled',
      'Expect RTCIceRole to be either controlling or controlled');

    assert_true(component === 'rtp' || component === 'rtcp',
      'Expect RTCIceComponent to be either rtp or rtcp');

    assert_true(state === 'connected' || state === 'completed',
      'Expect ICE transport to be in connected or completed state after data channels are connected');

    assert_true(gatheringState === 'gathering' || gatheringState === 'completed',
      'Expect ICE transport to be in gathering or completed gatheringState after data channels are connected');

    validateIceCandidates(iceTransport.getLocalCandidates());
    validateIceCandidates(iceTransport.getRemoteCandidates());

    const candidatePair = iceTransport.getSelectedCandidatePair();
    assert_not_equals(candidatePair, null,
      'Expect selected candidate pair to be non-null after ICE transport is connected');

    assert_true(candidatePair.local instanceof RTCIceCandidate,
      'Expect candidatePair.local to be instance of RTCIceCandidate');

    assert_true(candidatePair.remote instanceof RTCIceCandidate,
      'Expect candidatePair.remote to be instance of RTCIceCandidate');

    validateIceCandidateParameter(iceTransport.getLocalParameters());
    validateIceCandidateParameter(iceTransport.getRemoteParameters());
  }

  function validateUnconnectedIceTransport(iceTransport) {
    assert_array_equals(iceTransport.getRemoteCandidates(), [],
      'Expect iceTransport to not have any remote candidate');

    assert_equals(iceTransport.getSelectedCandidatePair(), null,
      'Expect selectedCandidatePair to be null');
  }

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();

    return createDataChannelPair(pc1, pc2)
    .then(() => {
      const iceTransport1 = getIceTransportFromSctp(pc1);
      const iceTransport2 = getIceTransportFromSctp(pc2);

      return Promise.all([
        waitConnectingIceTransport(iceTransport1),
        waitConnectingIceTransport(iceTransport2)
      ])
      .then(() => {
        validateConnectedIceTransport(iceTransport1);
        validateConnectedIceTransport(iceTransport2);
      });
    });
  }, 'SCTP - Connected ICE transports should have relevants attributes set');

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();

    return getTrackFromUserMedia('audio')
    .then(([track, mediaStream]) => {
      addTrackOrTransceiver(pc1, track, mediaStream);

      return doSignalingHandshake(pc1, pc2)
      .then(() => {
        const iceTransports1 = getIceTransportsFromSenderReceiver(pc1);
        const iceTransports2 = getIceTransportsFromSenderReceiver(pc2);

        const iceTransports = [...iceTransports1, ...iceTransports2];

        return Promise.all(iceTransports.map(
          iceTransport => {
            return waitConnectingIceTransport()
            .then(() => validateConnectedIceTransport(iceTransport));
          }));
      });
    });
  }, 'RTP - Connected ICE transports should have relevants attributes set');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return getTrackFromUserMedia('audio')
    .then(([track, mediaStream]) => {
      addTrackOrTransceiver(pc, track, mediaStream);

      // setLocalDescription should initialize sender/receiver.transport
      return pc.createOffer()
      .then(offer => pc.setLocalDescription(offer))
      .then(() => {
        const iceTransports = getIceTransportsFromSenderReceiver(pc);

        for (const iceTransport of iceTransports) {
          validateUnconnectedIceTransport(iceTransport);
        }
      });
    });
  }, 'RTP - Unconnected iceTransport should have empty remote candidates and selected pair');

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();
    pc1.createDataChannel('');

    // pc1.setRemoteDescription(answer) without pc2 setting answer to it's
    // localDescription. This is because pc1.sctp is only set after setting
    // answer description.
    return pc1.createOffer()
    .then(offer =>
      pc1.setLocalDescription(offer)
      .then(() => pc2.setRemoteDescription(offer))
      .then(() => pc2.createAnswer()))
    .then(answer => pc1.setRemoteDescription(answer))
    .then(() => {
      const iceTransport = getIceTransportFromSctp(pc1);

      validateUnconnectedIceTransport(iceTransport);
    });
  }, 'SCTP - Unconnected iceTransport should have empty remote candidates and selected pair');

</script>
