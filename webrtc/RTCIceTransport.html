<!doctype html>
<meta charset=utf-8>
<title>RTCIceTransport</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script src="RTCTransport-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //  createDataChannelPair
  //  awaitMessage
  //  getTrackFromUserMedia

  // The following helper functions are called from RTCTransport-helper.js:
  //  waitForConnectedState
  //  getDtlsTransportFromSctpTransport
  //  getDtlsTransportsFromSenderReceiver
  //  getIceTransportFromSctpTransport
  //  getIceTransportFromDtlsTransport
  //  getIceTransportsFromDtlsTransports

  function validateIceCandidates(candidates) {
    assert_greater_than(candidates.length, 0,
      'Expect at least one ICE candidate returned from get*Candidates()');

    for(const candidate of candidates) {
      assert_true(candidate instanceof RTCIceCandidate,
        'Expect candidate elements to be instance of RTCIceCandidate');
    }
  }

  function validateIceParameter(param) {
    assert_not_equals(param, null,
      'Expect candidate parameter to be non-null after peer connections are connected');

    assert_equals(typeof param.usernameFragment, 'string',
      'Expect param.usernameFragment to be set with string value');

    assert_equals(typeof param.password, 'string',
      'Expect param.password to be set with string value');
  }

  function validateConnectedIceTransport(iceTransport) {
    const { state, gatheringState, role, component } = iceTransport;

    assert_true(role === 'controlling' || role === 'controlled',
      'Expect RTCIceRole to be either controlling or controlled');

    assert_true(component === 'rtp' || component === 'rtcp',
      'Expect RTCIceComponent to be either rtp or rtcp');

    assert_true(state === 'connected' || state === 'completed',
      'Expect ICE transport to be in connected or completed state after peer connections are connected');

    assert_true(gatheringState === 'gathering' || gatheringState === 'completed',
      'Expect ICE transport to be in gathering or completed gatheringState after peer connections are connected');

    validateIceCandidates(iceTransport.getLocalCandidates());
    validateIceCandidates(iceTransport.getRemoteCandidates());

    const candidatePair = iceTransport.getSelectedCandidatePair();
    assert_not_equals(candidatePair, null,
      'Expect selected candidate pair to be non-null after ICE transport is connected');

    assert_true(candidatePair.local instanceof RTCIceCandidate,
      'Expect candidatePair.local to be instance of RTCIceCandidate');

    assert_true(candidatePair.remote instanceof RTCIceCandidate,
      'Expect candidatePair.remote to be instance of RTCIceCandidate');

    validateIceParameter(iceTransport.getLocalParameters());
    validateIceParameter(iceTransport.getRemoteParameters());
  }

  function validateUnconnectedIceTransport(iceTransport) {
    assert_array_equals(iceTransport.getRemoteCandidates(), [],
      'Expect iceTransport to not have any remote candidate');

    assert_equals(iceTransport.getSelectedCandidatePair(), null,
      'Expect selectedCandidatePair to be null');
  }

  promise_test(async t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());

    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    pc1.createDataChannel('');
    exchangeIceCandidates(pc1, pc2);

    await doSignalingHandshake(pc1, pc2);

    const dtlsTransport1 = getDtlsTransportFromSctpTransport(pc1.sctp);
    const dtlsTransport2 = getDtlsTransportFromSctpTransport(pc2.sctp);

    const iceTransport1 = getIceTransportFromDtlsTransport(dtlsTransport1);
    const iceTransport2 = getIceTransportFromDtlsTransport(dtlsTransport2);

    await waitForConnectedState(pc1);
    await waitForConnectedState(pc2);

    validateConnectedIceTransport(iceTransport1);
    validateConnectedIceTransport(iceTransport2);
  }, 'SCTP - Connected ICE transports should have relevants attributes set');

  promise_test(async t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());

    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    const [track] = await getTrackFromUserMedia('audio');
    pc1.addTransceiver(track);
    exchangeIceCandidates(pc1, pc2);

    await doSignalingHandshake(pc1, pc2);

    const dtlsTransports1 = getDtlsTransportsFromSenderReceiver(pc1);
    const dtlsTransports2 = getDtlsTransportsFromSenderReceiver(pc2);

    const iceTransports1 = getIceTransportsFromDtlsTransports(dtlsTransports1);
    const iceTransports2 = getIceTransportsFromDtlsTransports(dtlsTransports2);

    await waitForConnectedState(pc1);
    await waitForConnectedState(pc2);

    for (const iceTransport of iceTransports1) {
      validateConnectedIceTransport(iceTransport);
    }

    for (const iceTransport of iceTransports2) {
      validateConnectedIceTransport(iceTransport);
    }
  }, 'RTP - Connected ICE transports should have relevants attributes set');

  promise_test(async t => {
    const pc = new RTCPeerConnection();
    t.add_cleanup(() => pc.close());

    const [track] = await getTrackFromUserMedia('audio');
    pc.addTransceiver(track);

    // setLocalDescription should initialize sender/receiver.transport
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const iceTransports = getIceTransportsFromSenderReceiver(pc);

    for (const iceTransport of iceTransports) {
      validateUnconnectedIceTransport(iceTransport);
    }
  }, 'RTP - Unconnected iceTransport should have empty remote candidates and selected pair');

  promise_test(async t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());

    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    pc1.createDataChannel('');

    // pc1.setRemoteDescription(answer) without pc2 setting answer to it's
    // localDescription. This is because pc1.sctp is only set after setting
    // answer description.
    const offer = await pc1.createOffer()

    await pc1.setLocalDescription(offer)
    await pc2.setRemoteDescription(offer)
    const answer = await pc2.createAnswer()
    await pc1.setRemoteDescription(answer)

    const iceTransport = getIceTransportFromSctpTransport(pc1.sctp);
    validateUnconnectedIceTransport(iceTransport);
  }, 'SCTP - Unconnected iceTransport should have empty remote candidates and selected pair');

</script>
