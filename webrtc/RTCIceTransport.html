<!doctype html>
<meta charset=utf-8>
<title>RTCIceTransport</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script src="RTCTransport-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //  createDataChannelPair
  //  awaitMessage
  //  getTrackFromUserMedia
  //  addTrackOrTransceiver

  // The following helper functions are called from RTCTransport-helper.js:
  //  waitConnectingPc
  //  getIceTransportFromSctpTransport
  //  getIceTransportsFromSenderReceiver
  //  createIceTransportsFromSenderReceiver

  function validateIceCandidates(candidates) {
    assert_greater_than(candidates.length, 0,
      'Expect at least one ICE candidate returned from get*Candidates()');

    for(const candidate of candidates) {
     assert_true(candidate instanceof RTCIceCandidate,
       'Expect candidate elements to be instance of RTCIceCandidate');
    }
  }

  function validateIceParameter(param) {
   assert_not_equals(param, null,
     'Expect candidate parameter to be non-null after peer connections are connected');

   assert_equals(typeof param.usernameFragment, 'string',
     'Expect param.usernameFragment to be set with string value');

   assert_equals(typeof param.password, 'string',
     'Expect param.password to be set with string value');
  }

  function validateConnectedIceTransport(iceTransport) {
    const { state, gatheringState, role, component } = iceTransport;

    assert_true(role === 'controlling' || role === 'controlled',
      'Expect RTCIceRole to be either controlling or controlled');

    assert_true(component === 'rtp' || component === 'rtcp',
      'Expect RTCIceComponent to be either rtp or rtcp');

    assert_true(state === 'connected' || state === 'completed',
      'Expect ICE transport to be in connected or completed state after peer connections are connected');

    assert_true(gatheringState === 'gathering' || gatheringState === 'completed',
      'Expect ICE transport to be in gathering or completed gatheringState after peer connections are connected');

    validateIceCandidates(iceTransport.getLocalCandidates());
    validateIceCandidates(iceTransport.getRemoteCandidates());

    const candidatePair = iceTransport.getSelectedCandidatePair();
    assert_not_equals(candidatePair, null,
      'Expect selected candidate pair to be non-null after ICE transport is connected');

    assert_true(candidatePair.local instanceof RTCIceCandidate,
      'Expect candidatePair.local to be instance of RTCIceCandidate');

    assert_true(candidatePair.remote instanceof RTCIceCandidate,
      'Expect candidatePair.remote to be instance of RTCIceCandidate');

    validateIceParameter(iceTransport.getLocalParameters());
    validateIceParameter(iceTransport.getRemoteParameters());
  }

  function validateUnconnectedIceTransport(iceTransport) {
    assert_array_equals(iceTransport.getRemoteCandidates(), [],
      'Expect iceTransport to not have any remote candidate');

    assert_equals(iceTransport.getSelectedCandidatePair(), null,
      'Expect selectedCandidatePair to be null');
  }

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());

    return createIceTransportsFromSctp(pc1, pc2)
    .then(([iceTransport1, iceTransport2]) => {
      return Promise.all([
        waitConnectingPc(pc1),
        waitConnectingPc(pc2)
      ])
      .then(() => {
        validateConnectedIceTransport(iceTransport1);
        validateConnectedIceTransport(iceTransport2);
      });
    });
  }, 'SCTP - Connected ICE transports should have relevants attributes set');

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();

    return createIceTransportsFromSenderReceiver(pc1, pc2)
    .then(([iceTransports1, iceTransports2]) => {
      const iceTransports = [...iceTransports1, ...iceTransports2];
      return Promise.all([
        waitConnectingPc(pc1),
        waitConnectingPc(pc2)
      ])
      .then(() => {
        for (const iceTransport of iceTransports) {
          validateConnectedIceTransport(iceTransport);
        }
      });
    });
  }, 'RTP - Connected ICE transports should have relevants attributes set');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return getTrackFromUserMedia('audio')
    .then(([track, mediaStream]) => {
      addTrackOrTransceiver(pc, track, mediaStream);

      // setLocalDescription should initialize sender/receiver.transport
      return pc.createOffer()
      .then(offer => pc.setLocalDescription(offer))
      .then(() => {
        const iceTransports = getIceTransportsFromSenderReceiver(pc);

        for (const iceTransport of iceTransports) {
          validateUnconnectedIceTransport(iceTransport);
        }
      });
    });
  }, 'RTP - Unconnected iceTransport should have empty remote candidates and selected pair');

  promise_test(t => {
    const pc1 = new RTCPeerConnection();
    t.add_cleanup(() => pc1.close());
    const pc2 = new RTCPeerConnection();
    t.add_cleanup(() => pc2.close());
    pc1.createDataChannel('');

    // pc1.setRemoteDescription(answer) without pc2 setting answer to it's
    // localDescription. This is because pc1.sctp is only set after setting
    // answer description.
    return pc1.createOffer()
    .then(offer =>
      pc1.setLocalDescription(offer)
      .then(() => pc2.setRemoteDescription(offer))
      .then(() => pc2.createAnswer()))
    .then(answer => pc1.setRemoteDescription(answer))
    .then(() => {
      const iceTransport = getIceTransportFromSctpTransport(pc1.sctp);

      validateUnconnectedIceTransport(iceTransport);
    });
  }, 'SCTP - Unconnected iceTransport should have empty remote candidates and selected pair');

</script>
